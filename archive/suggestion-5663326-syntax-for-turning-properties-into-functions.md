# Idea 5663326: Syntax for turning properties into functions #

### Status : under-review

### Submitted by Gustavo Guerra on 3/21/2014 12:00:00 AM

### 457 votes

When we have F# records and classes (including the ones generated by type providers), we end up having to write things like this a lot:
(fun x -> x.Name)
It would be nice to have some shorthand for this, similar to what we can do with static members (but nicer than the Scala syntax please)


------------------------
## Comments


## Comment by Jon Harrop on 3/21/2014 11:29:00 AM
Doesn't SML use something like #Name?


## Comment by Loic Denuziere on 3/21/2014 11:42:00 AM
I think (.Name) (with the parentheses) would be readable and non-ambiguous.
On the other hand, a syntax that includes the class name would mean not having to reorder code to please the type inference.


## Comment by Richard Minerich on 3/21/2014 4:49:00 PM
I don't think this goes far enough. It would be nice to have some kind of first class typed handle to properties so we could more easily compose lenses for updating records as well.


## Comment by Richard Minerich on 3/21/2014 6:29:00 PM
You know, it might just be ideal to have some kind of auto generated lenses as in http://bugsquash.blogspot.com/2011/11/lenses-in-f.html
Although, it would be ideal to be able to compose them in such a way as to avoid having to reallocate for each and every update to the same record.


## Comment by Daniel Fabian on 3/21/2014 6:43:00 PM
I agree, that having auto generated lenses would be very nice. However, when we were generating lenses in our project, the mentioned approach turned out to be too weak to be very useful.
We ended up using partial lenses instead. The idea is, that with partial lenses you can create lenses for a specific case of a DU, as well as a field of a record, a component of a tuple or even an item in a list.


## Comment by Patrick Q on 3/22/2014 12:17:00 AM
This has been on my wish list for quite some time. I don't think the Scalar syntax is that bad, but I would prefer " # ", as Jon Harrop suggested.


## Comment by Mauricio Scheffer on 3/24/2014 7:16:00 PM
@Daniel Fabian: I don't think you can compare lenses with partial lenses like that... partial lenses are for sums, "regular" lenses are for products. You wouldn't use a partial lens for a record field or a tuple. (the definitions I use are the ones in http://dl.dropboxusercontent.com/u/7810909/media/doc/lenses.pdf )


## Comment by Daniel Fabian on 3/25/2014 3:29:00 AM
With partial lens, I meant { Get: 'T -> 'U option; Set: 'U -> 'T -> 'T }. And it works out perfectly fine also for tuples or records.
The idea being, we use the partial lenses for zooming somewhere deep into the object graph and then doing an update. Obviously, if you have a product type, the 'U option is not the preferred signature, because you are always in the Some case.
However, since our domain model is always a mix between DUs and records, the total lenses from your blog post or FSharpx were too constrained.
We just considered the lens to be a partial function that may or may not return a value. And when doing an update, the lens may or may not change something, depending on whether or not the lens triggered.
A typical lens would look like this
{ Get =
function
| Locator.Point2D (item1, item2) -> Some (item1, item2)
| _ -> None
Set = fun newValue union ->
match union with
| Locator.Point2D _ -> Locator.Point2D newValue
| _ -> union }
we are using this in production and it works very much as desired. The signatures, I took from https://hackage.haskell.org/package/data-lens-2.10.4/docs/Data-Lens-Partial-Common.html
If you want make a lens for a product type, you just need to wrap it in an additional Some.
And then the lens operators from FSharpx we adjusted to take into account the partial functions, so the compose will use Option.bind rather than function composition to compose two lenses, etc. But it works out nicely.
If you want to get rid of the 'T option, it could even be done so, that you lift a total lens to being a partial one, when combining it with a partial lens. And then with s some operator overloading this would also work out.
We didn't do this, though, because we use lenses to "change" some pre-existing object graph for the most part. And we felt like the occasional unpacking of the option was a small price to pay when compared to the added complexity of having a lot more overloads, adopting total lenses to make them partial etc.
If we were to extend the compiler though, I think making a distinction between total and partial lenses and properly lifting them on-demand might make sense.


## Comment by Richard Gibson on 3/25/2014 5:42:00 AM
I have always wanted this since I started using Linq some time ago when I wrote .Select(x => x.Name) for the 1000th time and thought "There must be a shorthand for this - I'm actually reducing readability by giving this lambda variable a name". I think that naming the variable in this case is giving completely irrelevant information that is actually detrimental to the readability.
Considering that this is one of the few times where F# is more verbose that C#, List.map (fun x -> x.Name) is even worse.
My favourite is the syntax that Livescript uses, where you can wrap a dot-access call in parens like it's an operator. The syntax in a complete example would look like this:
let lengths = ["One", "Two", "Three", "Four", "Five"]
|> map (.Length)


## Comment by Richard Gibson on 3/25/2014 5:59:00 AM
Incidentally, Livescript also allows you to do the equivalent of this:
["One", "Two", "Three", "Four", "Five"]
|> List.filter (.Length >= 4)


## Comment by Richard Gibson on 3/28/2014 11:16:00 AM
Another possibility for the syntax is to allow us to access instance methods and properties from a static context by passing in the instance as the last parameter. An existing example of this is the String.length property that is defined in the F# standard library, meaning that (given strings = ["hello"; "world"]) instead of
strings |> List.map (fun x -> x.Length)
I can write:
strings |> List.map String.length
This would also be okay I think


## Comment by Daniel Fabian on 3/28/2014 12:32:00 PM
You would have to find a way of avoiding ambiguities, though.


## Comment by Bryan Edds on 4/10/2014 8:54:00 PM
I believe the ideal syntax for this in F# would use precisely Loic's suggestion of -
(.Name)
This should be usable for all the different types of members including record fields, properties, object members, et al. The alternative of -
#Name
- would be confusingly close to SML's, collide with OCaml's object member syntax, and too far afield from F#'s intended syntax.


## Comment by Bryan Edds on 4/17/2014 10:04:00 PM
After further thought, I want to provide an alternative to this suggestion. While the original proposer suggested turning record fields AND class properties into functions, I think only the former should be suggested due to the weakness of the type inferencer.
Consider this -
type Record = { Member : int }
fun record -> record.Member // This line compiles fine...
(record.Member) // Therefore this syntax should remain a part of this proposal.
type Class (aMember : int) = let Member = aMember
fun obj -> obj.Member // This line does NOT compile!...
(obj.Member) // Therefore, this syntax should NOT be a part of this proposal.
I think we should concentrate only on getting the syntax working for record fields, and then once that hurdle is cleared, we should consider making the proposed syntax work for the other things that the inferencer is not so handy with.
* While I say the inferencer is weak in this case, I don't mean that as a critique. In fact, I think the weakness is beneficial and necessary to properly idiomatic programming in F#. A lot of people arbitrarily use classes in F# where a record would be more appropriate due to its functional idomaticy. Doing so confounds their API and pollutes the code of its end-users. Having the inferencer punish such practices by requiring noisy type annotations _is a good thing_. In doing so, we come to understand and respect the power of intelligent limitations.


## Comment by Craig Stuntz on 6/25/2014 3:55:00 PM
Related request: Add Lens focus unfocus [/archive/suggestion-6098767-add-lens-focus-unfocus](/archive/suggestion-6098767-add-lens-focus-unfocus.md)


## Comment by Dave Thomas on 7/6/2014 3:57:00 AM
Like Jon mentioned, first class selectors as described here would be perfect: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#records


## Comment by Dave Thomas on 7/6/2014 4:00:00 AM
The #3 style tuple selector would also be amazing: http://www.mpi-sws.org/~rossberg/sml-vs-ocaml.html#tuples


## Comment by Anonymous on 7/10/2014 6:22:00 AM
Great suggestion Gustavo - I like the idea of being able to use this shorthand:
type Something =
{
one: int
two: int
}
let ones = someSetOfSomethings |> List.map (.one)


## Comment by Vladimir Matveev on 7/10/2014 6:52:00 PM
using # as a marker for selectors does not play nice with compiler directives: #identifier at the beginning of the line is used by them. Alternatively we can try to adopt something Scala like: use _.<name>. I've tried to implement it (http://visualfsharp.codeplex.com/SourceControl/network/forks/vladima/primary?branch=selectors), looks kinda nice.


## Comment by Alfonso Garcia-Caro on 9/7/2014 9:13:00 AM
I would back the idea of having (.Name) just as syntactic sugar (with Intellisense, please) for (fun x -> x.Name)


## Comment by exercitus vir on 10/13/2014 11:02:00 AM
Of all the suggestions, I like Gibson's last suggestion the most.
List.map String.length
where String.Length is the property and String.length the corresponding function. It looks functional, plays nice with type inference and it's unambiguous (because of the lower case). Parenthesis are already too overloaded in F# for my taste.
To avoid incompatibilities with existing code, it might even be better to indicate explicitly that this is actually an instance method turned into a static method by prefixing it with ` (accent grave) or ^ (circumflex):
List.map String.`length
or
List.map String.^length
so that these "virtual" static methods only appear in Intellisense when you type:
String.`
or
String.^
These "virtual" static methods kind of feel like the inverse of C# extension methods, which turn static methods into "virtual" instance methods.


## Comment by exercitus vir on 10/13/2014 11:04:00 AM
(...continuing previous post:) Or maybe even:
List.map String#length


## Comment by Ovidiu Deac on 10/25/2014 5:49:00 PM
My thoughts:
1. The property functions should be namespaced properly to avoid name collisions. For this reason I'm against the approach .PropertyName suggested below
2. For starters doing it for record getters should be easy enough because one cannot define a record like this:
type Point =
{
x : int
y : int
}

static member x p = p.x
// Error FS0023: The member 'x' can not be defined because the name 'x' clashes with the field 'x' in this type or module (FS0023)
...so if the above static member Point.x is automatically generated it shouldn't break existing code
As Bryan Edds suggested below, this should also encourage people to use records more instead of classes.
3. I wouldn't bother with the setters for now. The field updates could be considered as a separate feature and it probably needs more consideration.
4. From the syntax perspective I think Point.x looks the most fsharp-ish.
5. If you want to extend that to classes and other functions I like Python approach that member functions are just static functions which take the self instance as the first parameter. This way I the method calls below are identical in Python:
c = MyClass()
c.memberFunction()
MyClass.memberFunction(c)
For me that's simple and intuitive.
I also like Robert Gibson's suggestion to put the instance parameter last for currying reasons.


## Comment by Bryan Edds on 12/23/2014 3:45:00 PM
To amend my previous comment, I have to say that I quite urgently would also like this functionality to work for non-record property getters now. This is because I now use type extensions to provide syntactically clean getters to dynamic record-style fields like so -
type Entity with
____member entity.CharacterType = entity?CharacterType : CharacterType
____static member setCharacterType (value : CharacterType) (entity : Entity) = entity?CharacterType <- value
With this, I can do this -
let ct = character.CharacterType
and
let c = Entity.setCharacterType ct c
I know this contradicts what I said earlier, but I need this functionality very badly. Doubly so in the face of needing first-class lenses in F# (that is, support for lensing with F# syntax rather than with a library - tho that is a different subject for the most part).


## Comment by Scott Wlaschin on 1/1/2015 7:36:00 PM
+1 to the "(.identifier)" syntax. Alternatively, extend the preexisting custom prefix operator syntax with (~identifier). You could even use the same syntax to create infix operators the same way, a la backticks in haskell.
For tuples you could use (.#1) (.#2) etc or if using tildes, (~1), (~2).
As to name resolution, surely you could use the same scoping rules as for members. That is, if "x" is a valid member name in the scope of Point, then (.x) is also a valid name when applied to Points. I don't know how type inference would work though...


## Comment by Richard Gibson on 1/15/2015 5:42:00 AM
Nice to see you here, Scott!
This would be a wonderful addition to the language, and I don't see any problem with type inference. (.name) would work wherever (fun x -> x.name) would, e.g.
Seq.map (.name) people // => Not okay
people |> Seq.map (.name) // => This is just fine
I also have no problem with the tilde syntax. Perhaps then you could drop the parens? E.g.
people |> Seq.map ~name


## Comment by luketopia on 2/8/2015 6:45:00 PM
What if we allowed the underscore to represent missing arguments to a member (including the instance), in which case a function for applying those arguments would be produced? Then we could do the following:
customers
|> Seq.map _.Name
|> File.WriteAllLines(@"C:\CustomerList.txt", _)
This would allow us to partially apply ordinary CLR methods with more than one argument, something I have always wanted.
I do still like the .Name syntax without the underscore, but that could be a special case (allow the underscore for the instance to be dropped).
I also think more complex expressions like _.Address.State could be supported. In this case, the entire expression would become a function. This would be distinct from (_.Address).State which would be a compiler error since (_.Address) is its own function.


## Comment by Greg Rosenbaum on 3/14/2015 7:15:00 PM
I think I prefer the #Property syntax, rather than the (.Property) syntax. This is mainly because I don't like extraneous parentheses. ~Property is also possible, but I tend to associate ~ with other things so it's a bit strange.
It would be great if it could be extended to instance methods, and not just properties. It would make chaining methods and module functions more convenient. Something like:
"blah" |> String.replicate 2 |> #Substring 1


## Comment by luketopia on 3/20/2015 8:57:00 PM
I don't see why the parentheses would be necessary at all. Elm doesn't need them for its record accessor syntax, for instance: http://elm-lang.org/learn/Records.elm#access


## Comment by Dmítrij Jevgénijevič Ačkásov on 7/19/2015 6:43:00 AM
Dot is an operator probably?
((.)Name)


## Comment by Jared Hester on 9/27/2015 6:45:00 AM
This functionality does exist in the form
.... let inline _Data x = ( ^a : ( member Data: 'b ) x )
Which works in situations like -
.... type Bottom = { Data:string }
.... type Middle = { Data:Bottom }
.... type Top = { Data:Middle }
.... let top = { Data = { Data = { Data = "bottom" }}}
.... let inline d3 x = ( _Data >> _Data >> _Data ) x ;;
.... d3 top
.... > val it : string = "bottom"
The suggested `.` notation seems like it might cause issues with partial application unless surrounded by parens, so it's probably better to use a different operator as a unary operator on an identifier to create a function like _Data. Some possibilities are
.... ( @. ) ___( @.Data ) <- my favorite option
.... ( .@ ) ___( .@Data )
.... ( @| ) ___( @|Data )
.... ( |@ ) ___( |@Data )
.... ( =| ) ____( =|Data )
.... ( |= ) ____( |=Data )
.... ( |- ) ____ ( |-Data )
.... ( -| ) ____ ( -|Data )
.... ( ./ ) ____ ( ./Data )
.... ( /. ) ____ ( /.Data )
.... ( |. ) ____ ( |.Data )
.... ( .| ) ____ ( .|Data )
.... ( !. ) ____ ( !.Data )
.... ( *@ ) ___ ( *@Data )
.... ( @* ) ___ ( @*Data )
.... ( -@ ) ___ ( -@Data )
.... ( @- ) ___ ( @-Data )
.... ( |* ) ____ ( |*Data )
.... ( *| ) ____ ( *|Data )
( these are all currently valid operators )


## Comment by Yaar Hever on 10/6/2015 8:50:00 PM
I like the idea of using a bare dot: List.map (.name),
but I think a better solution would be to have a fixed keyword for creating a lambda whose first and only argument is replaced by something. I've seen the usage of a keyword "it" in some language, but I can't remember which one it was.
This would allow not only: List.map (it.name)
but also: List.map (funcWithTupleArguments (arg1, arg2, it))
or even: List.map (sprintf "the square root of %f is %f\n" it (sqrt it))


## Comment by Varon on 10/15/2015 7:37:00 AM
The concept of 'functional properties' has been thoroughly explored under the name of Lenses in the formal side of the FP world.
There's an existing library that, if mixed with some code generation would probably perfectly work for this purpose. Don Syme has offered some comments relating to naming and usage in the "Conventions for Lens declarations" issue. You can read more about this on the github page at https://github.com/xyncro/aether .
Incidentally, this isn't the first time someone's asked for functional properties in F#. Another attempt is visible in the "Implement first-class lensing / lenses in F#". This seems to be a generalization of this suggestion.
You can view this alternative proposal here: [/archive/suggestion-6906132-implement-first-class-lensing-lenses-in-f](/archive/suggestion-6906132-implement-first-class-lensing-lenses-in-f.md) .
I would suggest that rather than implementing a less general syntactic workaround, we focus on working towards what we need for functional style properties (aka lenses).


## Comment by Ibrahim on 2/23/2016 1:58:00 PM
I was thinking about this syntax:
let f = MyType1.Member1
Where f is equivalent to Member1 with arguments prefix with the 'this' parameter of type 'MyType1'


## Comment by George on 2/29/2016 9:07:00 PM
Actually there are already partial solutions...
let Name a = a.Name
This is a little more exotic and a better explanation of the principals is in the F# language reference pdf and here: http://stackoverflow.com/questions/33161244/in-f-is-it-possible-to-have-a-tryparse-function-that-infers-the-target-type
let inline id (a:^a) = (^a : (member Id:'b) (a))
Essentially, static type constraints can be used to not only ensure that the parameter has a desired member (or static member) but also apply that member against the parameter to obtain a result.


## Comment by Dax Fohl on 3/25/2016 1:07:00 PM
Not only properties, but members of any kind. (e.g. I just found out about `Seq.map string` instead of `Seq.map (fun x -> x.ToString())` today.)
[/archive/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur](/archive/suggestion-5665355-add-syntactic-sugar-for-functions-ala-scala-clojur.md) seems to enable this but be even more generic, and I think less ugly syntax memorization than "(%$#) turns a member into a fn".
The only downside of that proposal I can see is that it *only* works in lambdas, but I don't see any reason I'd ever want to call a naked `%$#DoSomething myThing` instead of `myThing.DoSomething()` anyway.


## Comment by Abel on 9/25/2016 8:17:00 AM
Your title "turning properties into functions" suggests that F# wouldn't have support for this, but you can already do that (get the function accessor of the property):
let x = classWithNameProperty()
let f = x.get_Name // x.Name property as a function, f: unit -> string
But without the syntax decorations proposed in the comments, I don't see how this can be turned into a function if the object is not known (which is the second part of your request).
Unless you need this for many different properties, you can create your own object-less syntax using ducktyping, but this is "per property":
type MyTest() =
    member __.Name = "foo"
let inline name (x: ^a) = (^a: (member Name: string) x)
let f() =
    Seq.singleton (MyTest())
    |>Seq.map name                // works on any object in the seq with x.Name property
Of course, it would be much nicer to have standard syntax for this.

